{
  "entities": {
    "Sweet": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Sweet",
      "type": "object",
      "description": "Represents a sweet product in the shop's catalog.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Sweet entity."
        },
        "name": {
          "type": "string",
          "description": "The name of the sweet."
        },
        "description": {
          "type": "string",
          "description": "A detailed description of the sweet."
        },
        "category": {
          "type": "string",
          "description": "The category of the sweet (e.g., chocolate, candy, gummy)."
        },
        "price": {
          "type": "number",
          "description": "The price of the sweet."
        },
        "quantityInStock": {
          "type": "number",
          "description": "The current quantity of the sweet in stock."
        },
        "imageUrl": {
          "type": "string",
          "description": "URL of the image representing the sweet.",
          "format": "uri"
        }
      },
      "required": [
        "id",
        "name",
        "description",
        "category",
        "price",
        "quantityInStock"
      ]
    },
    "Customer": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Customer",
      "type": "object",
      "description": "Represents a customer of the sweet shop.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Customer entity."
        },
        "firstName": {
          "type": "string",
          "description": "The first name of the customer."
        },
        "lastName": {
          "type": "string",
          "description": "The last name of the customer."
        },
        "email": {
          "type": "string",
          "description": "The email address of the customer.",
          "format": "email"
        },
        "phoneNumber": {
          "type": "string",
          "description": "The phone number of the customer."
        },
        "address": {
          "type": "string",
          "description": "The address of the customer."
        }
      },
      "required": [
        "id",
        "firstName",
        "lastName",
        "email"
      ]
    },
    "Order": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Order",
      "type": "object",
      "description": "Represents a customer order.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Order entity."
        },
        "customerId": {
          "type": "string",
          "description": "Reference to Customer. (Relationship: Customer 1:N Order)"
        },
        "orderDate": {
          "type": "string",
          "description": "The date and time the order was placed.",
          "format": "date-time"
        },
        "totalAmount": {
          "type": "number",
          "description": "The total amount of the order."
        },
        "status": {
          "type": "string",
          "description": "The current status of the order (e.g., pending, processing, shipped, delivered)."
        }
      },
      "required": [
        "id",
        "customerId",
        "orderDate",
        "totalAmount",
        "status"
      ]
    },
    "OrderItem": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "OrderItem",
      "type": "object",
      "description": "Represents an item within an order.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the OrderItem entity."
        },
        "orderId": {
          "type": "string",
          "description": "Reference to Order. (Relationship: Order 1:N OrderItem)"
        },
        "sweetId": {
          "type": "string",
          "description": "Reference to Sweet. (Relationship: Sweet 1:N OrderItem)"
        },
        "quantity": {
          "type": "number",
          "description": "The quantity of the sweet in this order item."
        },
        "price": {
          "type": "number",
          "description": "The price of the sweet at the time of purchase."
        }
      },
      "required": [
        "id",
        "orderId",
        "sweetId",
        "quantity",
        "price"
      ]
    },
    "TrendPrediction": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TrendPrediction",
      "type": "object",
      "description": "Represents a trend prediction for sweet sales, generated by AI.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the TrendPrediction entity."
        },
        "predictionDate": {
          "type": "string",
          "description": "The date and time the prediction was generated.",
          "format": "date-time"
        },
        "geographicalSummary": {
          "type": "string",
          "description": "A geographical summary of the predicted trends."
        },
        "targetDemographics": {
          "type": "string",
          "description": "Suggested target demographics for the predicted trends."
        },
        "summary": {
          "type": "string",
          "description": "A summary for shop owners describing how and where they should focus sales."
        },
        "certainty": {
          "type": "number",
          "description": "A metric describing the certainty of the trend analysis tool."
        },
        "validity": {
          "type": "number",
          "description": "A metric describing the validity of the trend analysis tool."
        }
      },
      "required": [
        "id",
        "predictionDate",
        "geographicalSummary",
        "targetDemographics",
        "summary",
        "certainty",
        "validity"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "Customer",
          "schema": {
            "$ref": "#/backend/entities/Customer"
          },
          "description": "Stores customer data. Path-based ownership ensures only the user can access their own data.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            }
          ]
        }
      },
      {
        "path": "/sweets/{sweetId}",
        "definition": {
          "entityName": "Sweet",
          "schema": {
            "$ref": "#/backend/entities/Sweet"
          },
          "description": "Stores sweet product data. Accessible for listing sweets. Secure `list` operations.",
          "params": [
            {
              "name": "sweetId",
              "description": "The unique identifier for the sweet."
            }
          ]
        }
      },
      {
        "path": "/orders/{orderId}",
        "definition": {
          "entityName": "Order",
          "schema": {
            "$ref": "#/backend/entities/Order"
          },
          "description": "Stores order data.",
          "params": [
            {
              "name": "orderId",
              "description": "The unique identifier for the order."
            }
          ]
        }
      },
      {
        "path": "/orders/{orderId}/order_items/{orderItemId}",
        "definition": {
          "entityName": "OrderItem",
          "schema": {
            "$ref": "#/backend/entities/OrderItem"
          },
          "description": "Stores order items for a specific order.",
          "params": [
            {
              "name": "orderId",
              "description": "The unique identifier for the order."
            },
            {
              "name": "orderItemId",
              "description": "The unique identifier for the order item."
            }
          ]
        }
      },
      {
        "path": "/trend_predictions/{trendPredictionId}",
        "definition": {
          "entityName": "TrendPrediction",
          "schema": {
            "$ref": "#/backend/entities/TrendPrediction"
          },
          "description": "Stores trend prediction data generated by AI.",
          "params": [
            {
              "name": "trendPredictionId",
              "description": "The unique identifier for the trend prediction."
            }
          ]
        }
      },
      {
        "path": "/roles_admin/{userId}",
        "definition": {
          "entityName": "Customer",
          "schema": {
            "$ref": "#/backend/entities/Customer"
          },
          "description": "Stores admin roles based on user ID. Existence implies admin access.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore data structure is designed to support the Sweet Shop Management System. It emphasizes authorization independence and straightforward security rules. User data is stored under `/users/{userId}`. Sweets are stored in a top-level `/sweets` collection, allowing for easy listing and searching. Orders are stored under `/orders/{orderId}`. Order items related to each order will be stored as subcollections under `/orders/{orderId}/order_items`. Trend predictions generated by AI are stored in the `/trend_predictions` collection, providing insights into sales trends and demographics. Admin roles are managed via the `/roles_admin/{userId}` collection. This design ensures clear separation of data and facilitates efficient querying and management of the sweet shop's operations. This structure incorporates denormalization where necessary to achieve authorization independence and supports the required QAPs through structural segregation and membership models. Specifically, the segregation of admin roles into a separate collection `/roles_admin/{userId}` enables simple existence-based security rules for admin-only operations like deleting or restocking sweets."
  }
}